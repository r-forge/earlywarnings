defaults write org.R-project.R force.LANG en_US.UTF-8
help("defaults")
? corSpatial
corSpatial
? corSpatial
logit
x<-seq(1,12, by=0.1)
xt<-logit(385.7*(x-5.41),min=0.91,max=0,94)
library(Rcmdr)
?logit
x<-seq(1,12, by=0.1)
xt<-logit(385.7*(x-5.41),min=0.91,max=0,94)
xt<-logit(385.7*(x-5.41),min=0.91,max=0.94)
xt<-logit(x,min=0.91,max=0.94)
plot(xt)
st
xt
xt<-logit(385.7*(x-5.41),min=0.91,max=0.94)
xt
xt<-logit(x,min=0,max=1)
?logit
x<-seq(0,10, by=0.1)
xt<-logit(x,min=0,max=10)
plot(xt)
xt<-logit(385.7*(x-5.41),min=0.91,max=0.94)
x<-seq(0.91,0.94, by=0.1)
x<-seq(0.91,0.94, by=0.001)
xt<-logit(385.7*(x-5.41),min=0.91,max=0.94)
xt
x<-seq(1,12, by=0.001)
xt<-logit(385.7*(x-5.41),min=1,max=12)
xt
x<-seq(1,12, by=0.1)
xt<-logit(385.7*(x-5.41),min=1,max=12)
xt
?logit
xt<-logit(385.7*(x-5.41),min=0.91,max=0.94)
xt
source("/Users/vasilisdakos/Dropbox/current_projects/Paper_PhilTransSpIssue/R_trends_bandwidth_slidingwindow.r")
rm(list=ls(all=TRUE))#
#
library(lmtest)#
library(nortest)#
library(stats)#
library(som)#
library(Kendall)#
library(KernSmooth)#
library(e1071)
library(lmtest)
? acf
?cor
Y<-rand(500,1)
?bds.test
# Drift Diffusion Jump Nonparametrics Early Warning Signals#
# Author: Stephen R Carpenter, 15 December 2011#
# Modified by: Vasilis Dakos, January 4, 2012#
#
require('KernSmooth')#
#
# Function to compute Bandi, Johannes etc estimators for time series x#
# Inputs:#
#  x0 is the regressor#
#  dx is the first difference of x0#
#  nx is number of first differences#
#  DT is time step#
#  bw is the bandwidth for the kernel#
#  na is number of a values for computing the kernel#
#  avec is the mesh for the kernel#
#
Bandi5 <- function(x0,dx,nx,DT,bw,na,avec)  {#
# Set up constants and useful preliminaries#
SF <- 1/(bw*sqrt(2*pi))  # scale factor for kernel calculation#
x02 <- x0*x0 # second power of x#
dx2 <- dx*dx # second power of dx#
dx4 <- dx2*dx2  # fourth power of dx#
dx6 <- dx2*dx4  # sixth power of dx#
# Compute matrix of kernel values#
Kmat <- matrix(0,nrow=na,ncol=nx)#
for(i in 1:(nx)) {  # loop over columns (x0 values)#
  Kmat[,i] <- SF*exp(-0.5*(x0[i]-avec)*(x0[i]-avec)/(bw*bw))#
  }#
# Compute M1, M2, M4, moment ratio and components of variance for each value of a#
M1.a <- rep(0,na)#
M2.a <- rep(0,na)#
M4.a <- rep(0,na)#
M6M4r <- rep(0,na)  # vector to hold column kernel-weighted moment ratio#
mean.a <- rep(0,na) # centering of conditional variance#
SS.a <- rep(0,na)  # sum of squares#
for(i in 1:na) {  # loop over rows (a values)#
  Ksum <- sum(Kmat[i,])  # sum of weights#
  M1.a[i] <- (1/DT)*sum(Kmat[i,]*dx)/Ksum#
  M2.a[i] <- (1/DT)*sum(Kmat[i,]*dx2)/Ksum#
  M4.a[i] <- (1/DT)*sum(Kmat[i,]*dx4)/Ksum#
  M6.c <- (1/DT)*sum(Kmat[i,]*dx6)/Ksum#
  M6M4r[i] <- M6.c/M4.a[i]#
  mean.a[i] <- sum(Kmat[i,]*x0[2:(nx+1)])/Ksum #
  SS.a[i] <- sum(Kmat[i,]*x02[2:(nx+1)])/Ksum #
  }#
# Compute conditional variance#
S2.x <- SS.a - (mean.a*mean.a) # sum of squares minus squared mean#
# Compute jump frequency, diffusion and drift#
sigma2.Z <- mean(M6M4r)/(5) # average the column moment ratios#
lamda.Z <- M4.a/(3*sigma2.Z*sigma2.Z)#
sigma2.dx <- M2.a - (lamda.Z*sigma2.Z)#
# set negative diffusion estimates to zero#
diff.a <- ifelse(sigma2.dx>0,sigma2.dx,0)#
sigma2.dx <- M2.a     # total variance of dx#
mu.a <- M1.a#
outlist <- list(mu.a,sigma2.dx,diff.a,sigma2.Z,lamda.Z,S2.x)#
# outputs of function:#
# mu.a is drift#
# sigma2.dx is total variance of dx#
# diff.a is diffusion#
# sigma2.Z is jump magnitude#
# lamda.Z is jump frequency#
# S2.x is conditional variance#
return(outlist)#
} # end Bandi function#
#
# MAIN FUNCTION#
ddjnonparam_ews<-function(timeseries,bandwidth=0.6,na=500,logtransform=TRUE,interpolate=FALSE){#
#
	# Create timeindex vector and data vector#
	if (is.null(dim(timeseries)[2])){#
		Y<-timeseries#
		timeindex<-1:length(timeseries)#
		}else if(dim(timeseries)[2]==2){#
		Y<-timeseries[,2]#
		timeindex<-timeseries[,1]#
		}else{#
		warning("not right format of timeseries input")#
		}#
		#
	# Interpolation#
	if (interpolate){#
		YY<-approx(timeindex,Y,n=length(Y),method="linear")#
		Y<-YY$y#
		}else{#
		Y<-Y}#
			#
	# Log-transformation#
	if (logtransform){#
		Y<-log(Y+1)}#
		#
	# Preliminaries#
	Xvec1<-Y#
	Tvec1<-timeindex#
	dXvec1 <- diff(Y)#
#
	DT <- Tvec1[2]-Tvec1[1]#
	bw <- bandwidth*sd(Xvec1) # bandwidth #
	alow <- min(Xvec1)#
	ahigh <- max(Xvec1)#
	na <- na#
	avec <- seq(alow,ahigh,length.out=na)#
	nx <- length(dXvec1)#
#
	# Bandi-type estimates#
	ParEst <- Bandi5(Xvec1,dXvec1,nx,DT,bw,na,avec)#
	Drift.vec <- ParEst[[1]]#
	TotVar.dx.vec <- ParEst[[2]]	#
	Diff2.vec <- ParEst[[3]]#
	Sigma2Z <- ParEst[[4]]#
	LamdaZ.vec <- ParEst[[5]]#
	S2.vec <- ParEst[[6]]#
#
	# Interpolate time courses of indicators#
	TotVar.i <- approx(x=avec,y=TotVar.dx.vec,xout=Xvec1)#
	TotVar.t <- TotVar.i$y#
	Diff2.i <- approx(x=avec,y=Diff2.vec,xout=Xvec1)#
	Diff2.t <- Diff2.i$y#
	Lamda.i <- approx(x=avec,y=LamdaZ.vec,xout=Xvec1)#
	Lamda.t <- Lamda.i$y#
	S2.i <- approx(x=avec,y=S2.vec,xout=Xvec1)#
	S2.t <- S2.i$y#
#
	# Plot the data#
	dev.new()#
	par(mfrow=c(2,1),mar=c(3, 3, 2, 2),mgp=c(1.5,0.5,0),oma=c(1,1,1,1))#
	plot(Tvec1,Xvec1,type='l',col='black',lwd=2,xlab='',ylab='original data')#
	grid()#
	plot(Tvec1[1:length(Tvec1)-1],dXvec1,type='l',col='black',lwd=2,xlab='time',ylab='first-diff data')#
	grid()#
	#
	# Plot indicators versus a#
	dev.new()#
	par(mfrow=c(2,2),mar=c(3, 3, 2, 2) ,cex.axis=1,cex.lab=1,mgp=c(2,1,0),oma=c(1,1,2,1))#
	plot(avec,S2.vec,type='l',lwd=1,col='black',xlab='a',ylab='conditional variance')#
	plot(avec,TotVar.dx.vec,type='l',lwd=1,col='blue',xlab='a',ylab='total variance of dx')#
	plot(avec,Diff2.vec,type='l',lwd=1,col='green',xlab='a',ylab='diffusion')#
	plot(avec,LamdaZ.vec,type='l',lwd=1,col='red',xlab='a',ylab='jump intensity')#
	mtext("DDJ nonparametrics versus a",side=3,line=0.1,outer=TRUE)#
	#
	# Plot indicators versus time#
	dev.new()#
	par(mfrow=c(2,2),mar=c(3, 3, 2, 2),cex.axis=1,cex.lab=1,mgp=c(1.5,0.5,0),oma=c(1,1,2,1))#
	plot(Tvec1,S2.t,type='l',lwd=1,col='black',xlab='time',ylab='conditional variance')#
	plot(Tvec1,TotVar.t,type='l',lwd=1,col='blue',xlab='time',ylab='total variance of dx')#
	plot(Tvec1,Diff2.t,type='l',lwd=1,col='green',xlab='time',ylab='diffusion')#
	plot(Tvec1,Lamda.t,type='l',lwd=1,col='red',xlab='time',ylab='jump intensity')#
	mtext("DDJ nonparametrics versus time",side=3,line=0.1,outer=TRUE)#
#
	# Output#
	nonpar_x<-data.frame(S2.vec,TotVar.dx.vec,Diff2.vec,LamdaZ.vec)#
	#out$x<-nonpar_x#
#
	nonpar_t<-data.frame(S2.t,TotVar.t,Diff2.t,Lamda.t)#
	#out$t<-nonpar_t#
	return(data.frame(nonpar_x,nonpar_t))#
	}
?bds.test
require(tseries)
?bds.test
Y=rnorm(100)
Y
Y=rnorm(500)
ss=ddjnonparam_ews(timeseries,bandwidth=0.6,na=500,logtransform=TRUE,interpolate=FALSE)
ss=ddjnonparam_ews(Y,bandwidth=0.6,na=500,logtransform=TRUE,interpolate=FALSE)
Y=rnorm(500)+10
ss=ddjnonparam_ews(Y,bandwidth=0.6,na=500,logtransform=TRUE,interpolate=FALSE)
ss
head(ss)
?data
getwd()
xx=read.table('CSD_6Dec11.txt',header=FALSE)
dim(xx)
plot(xx[,3])
plot(xx[,4])
plot(xx[,3])
plot(xx[1"970",3])
plot(xx[1:970,3])
write.table('foldbif.txt',xx[1:970,3])
?write.table
write.table(xx[1:970,3],'foldbif.txt')
write.table(xx[1:970,3],'foldbif.txt',col.names=FALSE)
write.table(xx[1:970,3],'foldbif.txt',col.names=FALSE,row.names=FALSE)
xx=read.table('foldbif.txt',header=FALSE)
plot(xx)
xx
dim(xx)
plot(xx''
plot(xx')
cc=xx''
cc=xx'
plot(ts(xx))
write.table
?write.table
xxx=data.frame(xx)
dim(xxx)
xxx
head(xxx)
xxx=data.frame(xx,col.names=FALSE)
head(xxx)
?data.frame
xxx=data.frame(xx,row.names=NULL)
head(xxx)
write.table(xxx,'foldbif.txt',col.names=FALSE,row.names=FALSE)
xx=read.table('foldbif.txt',header=FALSE)
head(xx)
xx=read.csv('foldbif.txt',header=FALSE)
head(xx)
?read.table
xx=read.delim('foldbif.txt',header=FALSE)
head(xx)
plot(xx)
xx=read.table('CSD_6Dec11.txt',header=FALSE)
head(xx)
plot(xx[,3])
xx=read.delim('foldbif.txt',header=FALSE)
head(xx)
plot(xx)
plot(xx[,1])
Y=xx
plot(Y)
Y[1]
Y[2]
Y[1,]
Y[1,1]
plot(1:length(Y),Y)
plot(ts(1:length(Y)),Y)
length(Y)
xx=read.table('CSD_6Dec11.txt',header=FALSE)
length(xx)
dim(xx)
?length
?data
xx=data('CSD_6Dec11.txt')
# Conditional Heteroskedasticity#
# Author: Timothy Cline, October 25, 2011.#
# Modified by: Vasilis Dakos, January 3, 2012.#
#
ch_ews<-function(timeseries, winsize = 10, alpha=0.1, optim=TRUE,lags=4){#
	#ts.in<-ts(timeseries) #strict data-types the input data as tseries object for use in later steps#
	if (is.null(dim(timeseries)[2])){#
		ts.in=timeseries#
		timeindex=1:length(ts.in)#
		}else if(dim(timeseries)[2]==2){#
		ts.in=timeseries[,2]#
		timeindex=timeseries[,1]#
 		}else{#
		warning("not right format of timeseries input")#
		}#
				#
	winSize=round(winsize*length(ts.in)/100)#
	sto<-matrix(nrow=(length(ts.in)-(winSize-1)),ncol=5) # creates a matrix to store output#
	#
	count<-1 #place holder for writing to the matrix#
	for(i2 in winSize:length(ts.in)){ # loop to iterate through the model values by window lengths of the input value#
		#
		#the next line applys the autoregressive model optimized using AIC #
		#then we omit the first data point(s) which come back as NA #
		#and square the residuals#
		if(optim==TRUE){#
			arm<-ar(ts.in[(i2-(winSize-1)):i2],method='ols')#
		}else{#
			arm<-ar(ts.in[(i2-(winSize-1)):i2],aic=FALSE,order.max=lags,method='ols')		}#
		resid1<-na.omit(arm$resid)^2#
		#
		l1<-length(resid1) # stores the number of residuals for many uses later#
		lm1<-lm(resid1[2:l1]~resid1[1:(l1-1)])#calculates simple OLS model of describing t+1 by t#
		#
		# calculates the critical value: Chi-squared critical value using desired #
		# alpha level and 1 degree of freedom / number of residuals used in regression#
		critical<-qchisq((1-alpha),df=1)/(length(resid1)-1) #
		#
		sto[count,1]<-timeindex[i2] # stores a time component#
		sto[count,2]<-summary(lm1)$r.squared # stores the r.squared for this window#
		sto[count,3]<-critical # stores the critical value#
		#
		# the next flow control group stores a simple 1 for significant test or 0 for non-significant test#
		if(summary(lm1)$r.squared>critical){#
			sto[count,4]<-1#
		}else{sto[count,4]<-0}#
		sto[count,5]<-arm$order#
		count<-count+1	# increment the place holder#
	}#
	#
	sto<-data.frame(sto) # data types the matrix as a data frame#
	colnames(sto)<-c("time","r.squared","critical.value","test.result","ar.fit.order") # applies column names to the data frame#
	#
	#This next series of flow control statements will adjust the max and minimum values to yield prettier plots#
	#In some circumstances it is possible for all values to be far greater or far less than the critical value; in all cases we want the critical line ploted on the figure#
	if(max(sto$r.squared)<critical){#
		maxY<-critical+0.02  #
		minY<-critical-0.02#
	}else if(min(sto$r.squared>=critical)){#
		minY<-critical-0.02#
		maxY<-critical+0.02#
	}else{#
		maxY<-max(sto$r.squared)#
		minY<-min(sto$r.squared)#
  }                       #
    #
	#this creates a very simple plot that is well fitted to the data. #
	#it also plots the critical value line	#
#
	par(mar=(c(0,4,0,1)+0),oma=c(5,1,2,1),mfrow=c(2,1))#
	plot(timeindex,ts.in,type="l",ylab="data",xlab="",cex.axis=0.8,cex.lab=0.8,xaxt="n",las=1,xlim=c(timeindex[1],timeindex[length(timeindex)]))#
	plot(timeindex[winSize:length(timeindex)],sto$r.squared,ylab=expression(paste("R^2")),xlab="time",type="b",cex=0.5,cex.lab=0.8, cex.axis=0.8,las=1,ylim=c(min(sto$r.squared),max(sto$r.squared)),xlim=c(timeindex[1],timeindex[length(timeindex)]))#
	legend("topleft","conditional heteroskedasticity",bty = "n")#
	abline(h=sto$critical,lwd=0.5,lty=2,col=2)#
	mtext("time",side=1,line=2,cex=0.8)#outer=TRUE print on the outer margin#
	#
	return(sto)#
}
head(xx)
head(x)
head(xxx)
plot(xxx)
ch_ews(xxx)
ch_ews(ts(xxx))
w=ts(xxx)
plot(w)
ch_ews(ts(xxx))
ch_ews(w)
dim(w)
p=as.vector(w)
head(p)
ch_ews(p)
?write
write(p,'foldbif.txt')
xx=read.delim('foldbif.txt',header=FALSE)
dim(xx)
head(xx)
getwd()
dim(p)
length(p)
write(p,'foldbif.txt',ncolumns=1)
xx=read.delim('foldbif.txt',header=FALSE)
head(xx)
dim(xx)
length(xx)
plot(xx)
plot(p)
?read.table
xx=read.delim('foldbif.txt',header=FALSE)
plot(xx)
xx=read.delim('foldbif.txt',header=TRUE)
plot(xx)
head(xx)
xx=read.delim('foldbif.txt',header=FALSE)
xx=scan('foldbif.txt',header=FALSE)
xx=scan('foldbif.txt')
plot(xx)
dim(x)
dim(xx)
source("/Users/vasilisdakos/Dropbox/early_warning_tools_&_data_sets/R_code/Rpackage/earlywarnings/man/generic_ews.Rd")
?plot
?bds.test
load("/Users/vasilisdakos/Documents/warningsignals/data/glaciationIII.rda")
load("/Users/vasilisdakos/Documents/warningsignals/data/glaciationIII.rda")
a=load("/Users/vasilisdakos/Documents/warningsignals/data/glaciationIII.rda")
a
a[1]
a[2]
a[2,]
a[,2]
?data
?install.package
?install.packages
?data
library(earlywarnings)
?earlywarnings
?generic_ews
data("foldbif")
foldbif
plot(foldbif)
plot(as.matrix(foldbif))
data(circulation)
plot(circulation)
head(circulation)
head(circulation)?
?bandi5
?ch_ews
?ch_ews
?ch_ews
